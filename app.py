import os
import uuid
import re
import requests
import streamlit as st
from dotenv import load_dotenv
from gtts import gTTS
from pdf2image import convert_from_bytes
import datetime
from camel_agents import MedicalReportAssistant
from reportlab.lib.pagesizes import A4
from reportlab.pdfgen import canvas
from reportlab.lib import colors
from reportlab.lib.units import inch
import pandas as pd
import numpy as np
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Dropout
from sklearn.preprocessing import StandardScaler, LabelEncoder
import threading
import time
from PIL import Image
import tensorflow as tf


def generate_pdf(summary_text, medicine_text, output_path="MedScope_Report.pdf"):
    """Generate a formatted PDF report containing summary and medicine suggestions."""
    c = canvas.Canvas(output_path, pagesize=A4)
    width, height = A4

    # Title
    c.setFont("Helvetica-Bold", 18)
    c.setFillColor(colors.HexColor("#0072ff"))
    c.drawString(1 * inch, height - 1 * inch, "ü©∫ MedScope AI Analysis Report")

    # Divider
    c.setStrokeColor(colors.HexColor("#00c6ff"))
    c.setLineWidth(2)
    c.line(1 * inch, height - 1.1 * inch, width - 1 * inch, height - 1.1 * inch)

    # Key Findings Section
    c.setFont("Helvetica-Bold", 14)
    c.setFillColor(colors.black)
    c.drawString(1 * inch, height - 1.5 * inch, "Doctor‚Äôs AI Opinion:")

    text_obj = c.beginText(1 * inch, height - 1.8 * inch)
    text_obj.setFont("Helvetica", 11)
    text_obj.setFillColor(colors.black)
    for line in summary_text.split("\n"):
        text_obj.textLine(line.strip())
    c.drawText(text_obj)

    # Medicine Recommendations Section
    y_position = text_obj.getY() - 0.5 * inch
    c.setFont("Helvetica-Bold", 14)
    c.setFillColor(colors.black)
    c.drawString(1 * inch, y_position, "üíä Recommended Medicines:")

    text_obj2 = c.beginText(1 * inch, y_position - 0.3 * inch)
    text_obj2.setFont("Helvetica", 11)
    for line in medicine_text.split("\n"):
        text_obj2.textLine(line.strip())
    c.drawText(text_obj2)

    # Footer note
    y_position2 = text_obj2.getY() - 0.5 * inch
    c.setFont("Helvetica-Oblique", 10)
    c.setFillColor(colors.grey)
    c.drawString(1 * inch, y_position2, "‚ö†Ô∏è This report is for informational purposes only. Consult a doctor before taking any medication.")

    # Footer
    c.setFont("Helvetica", 9)
    c.setFillColor(colors.darkgray)
    c.drawCentredString(width / 2, 0.5 * inch, "Generated by MedScope AI | ¬© 2025")

    c.save()
    return output_path

# ---------------- CHEST X-RAY MODEL LOADER ----------------
@st.cache_resource
def load_chest_model():
    model_path = "/home/ubuntu/MedScopeAI/ChestVisionNet.h5"
    model = tf.keras.models.load_model(model_path)
    return model

chest_model = load_chest_model()

CHEST_IMG_SIZE = (150, 150)
CHEST_CLASS_LABELS = ["Normal", "Pneumonia"]

# ---------------------------
# 1. Load environment
# ---------------------------
load_dotenv("api.env")


# ---------------------------
# 2. Session state init
# ---------------------------
if "uploaded_file" not in st.session_state:
    st.session_state.uploaded_file = None
if "file_bytes" not in st.session_state:
    st.session_state.file_bytes = None


def clear_file():
    """Reset stored file in session state."""
    st.session_state.uploaded_file = None
    st.session_state.file_bytes = None


st.session_state.clear_file = clear_file


# ---------------------------
# 3. Page configuration
# ---------------------------
st.set_page_config(
    page_title="MedSMedScope AI‚ö°",
    page_icon="‚öïÔ∏è",
    layout="wide",
    initial_sidebar_state="expanded"
)


# ---------------------------
# 4. Custom CSS & Header
# ---------------------------
st.markdown("""
<style>
  /* Overall App Background */
  [data-testid=stAppViewContainer] {
      background-color: #0f0f0f;
      color: white;
      font-family: 'Poppins', sans-serif;
  }

  /* Header Container */
  .header-container {
      text-align: center;
      margin: 3rem 0 2rem 0;
      position: relative;
  }

  /* Title Styling */
  .header-container .title {
      font-size: 3rem;
      font-weight: 800;
      background: linear-gradient(90deg, #00c6ff, #0072ff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-transform: uppercase;
      letter-spacing: 2px;
  }

  /* Subheading / Tagline */
  .header-container .tagline {
      font-size: 1.2rem;
      color: #b0bec5;
      margin-top: 0.5rem;
      letter-spacing: 1px;
      font-style: italic;
  }

  /* Divider line */
  .divider {
      width: 120px;
      height: 3px;
      background: linear-gradient(90deg, #00c6ff, #0072ff);
      border-radius: 10px;
      margin: 1rem auto;
  }

  /* Result box */
  .result-box {
      background: #1c1c1c;
      padding: 1.5rem;
      border-radius: 10px;
      margin-bottom: 1.5rem;
      box-shadow: 0 0 20px rgba(0, 150, 255, 0.1);
  }
  .result-box h1, .result-box h2, .result-box h3, .result-box h4 {
      color: #ffffff;
  }
  .result-box p, .result-box li {
      color: #dcdcdc;
  }

  /* Audio player section */
  .audio-container {
      background: #1e1e1e;
      padding: 20px;
      border-radius: 10px;
      margin-top: 30px;
      text-align: center;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
  }
  .audio-container h4 {
      color: #4fc3f7;
      margin-bottom: 15px;
      font-size: 1.3em;
  }
  .audio-container audio {
      width: 100%;
      border-radius: 10px;
      border: 1px solid #4fc3f7;
  }
  .audio-btn {
      background-color: #4fc3f7;
      color: white;
      padding: 10px 20px;
      border: none;
      border-radius: 5px;
      font-size: 1.1em;
      cursor: pointer;
      margin-top: 10px;
      transition: 0.3s;
  }
  .audio-btn:hover {
      background-color: #1976d2;
      transform: scale(1.05);
  }
</style>

<!-- Header Section -->
<div class="header-container">
    <span class="title">‚ö° MedScope AI ‚ö°</span>
    <div class="divider"></div>
    <p class="tagline">Empowering healthcare with intelligent insights.</p>
</div>
""", unsafe_allow_html=True)


# ---------------------------
# 5. Theme helper
# ---------------------------
def set_theme():
    """Additional theme settings (if needed)."""
    # Placeholder for any Python-based theme logic
    pass


set_theme()
# ---------------------------
# 5.5 Neural Network Disease Prediction Model
# ---------------------------

@st.cache_resource
def load_disease_model():
    """Train neural network model for disease prediction."""
    df = pd.read_csv("/home/ubuntu/MedScopeAI/merged_medical_dataset.csv")

    le = LabelEncoder()
    df["Disease_encoded"] = le.fit_transform(df["Disease"])

    X = df.select_dtypes(include=["number"])
    y = df["Disease_encoded"]

    scaler = StandardScaler()
    X_scaled = scaler.fit_transform(X)

    num_classes = len(np.unique(y))
    model = Sequential([
        Dense(128, activation='relu', input_dim=X_scaled.shape[1]),
        Dropout(0.3),
        Dense(64, activation='relu'),
        Dropout(0.3),
        Dense(num_classes, activation='softmax')
    ])
    model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])
    model.fit(X_scaled, y, epochs=25, batch_size=32, verbose=0)

    return model, scaler, le, X.columns.tolist()

model, scaler, label_encoder, feature_names = load_disease_model()



# ---------------------------
# 6. Sidebar: File upload
# ---------------------------
with st.sidebar:
    st.subheader("üìÅ Upload Medical Report")
    uploaded = st.file_uploader(label="", type=["pdf"], label_visibility="collapsed")

    if uploaded:
        st.session_state.uploaded_file = uploaded
        st.session_state.file_bytes = uploaded.getbuffer()

        st.button("üóëÔ∏è Clear Uploaded File", on_click=st.session_state.clear_file)

        with st.expander("üìÑ Preview Report Pages", expanded=False):
            try:
                poppler_path = r"C:\Users\Admin\Downloads\Release-25.07.0-0\poppler-25.07.0\Library\bin"
                images = convert_from_bytes(
                    st.session_state.file_bytes,
                    dpi=200,
                    size=(800, None),
                    poppler_path=poppler_path
                )
                for i, img in enumerate(images, start=1):
                    st.image(img, caption=f"Page {i}", use_container_width=True)
                st.success(f"‚úÖ Showing all {len(images)} pages.")
            except Exception as e:
                st.warning("""
                ‚ö†Ô∏è Could not preview PDF.  
                Please ensure **Poppler** is installed and the path is correct.  
                """)
                st.error(f"Technical details: {e}")


# ---------------------------
# 7. Utility functions
# ---------------------------
def clean_text(text: str) -> str:
    """Remove non-alphanumeric characters for TTS."""
    return re.sub(r"[^\w\s]", "", text)


def generate_audio(text: str) -> str:
    """
    Generate an MP3 from cleaned text via gTTS.
    Returns the path to the audio file.
    """
    cleaned = clean_text(text)
    audio_path = "temp_result_audio.mp3"
    tts = gTTS(text=cleaned, lang="en")
    tts.save(audio_path)
    return audio_path
def extract_lab_values(text):
    """Improved regex to correctly extract full numerical lab values."""
    patterns = {
        "Glucose": r"(glucose|blood sugar)[^\d]*(\d{2,3}\.?\d*)",
        "TSH": r"(TSH)[^\d]*(\d{1,3}\.?\d*)",
        "T3": r"(T3)[^\d]*(\d{1,3}\.?\d*)",
        "T4": r"(T4)[^\d]*(\d{1,3}\.?\d*)",
        "Hemoglobin": r"(hemoglobin|Hb)[^\d]*(\d{1,2}\.?\d*)",
        "Cholesterol": r"(cholesterol)[^\d]*(\d{2,3}\.?\d*)",
        "AST": r"(AST|SGOT)[^\d]*(\d{1,3}\.?\d*)",
        "ALT": r"(ALT|SGPT)[^\d]*(\d{1,3}\.?\d*)",
        "Creatinine": r"(creatinine)[^\d]*(\d{1,2}\.?\d*)",
        "Bilirubin": r"(bilirubin)[^\d]*(\d{1,2}\.?\d*)",
        "Platelets": r"(platelet)[^\d]*(\d{1,3}\.?\d*)",
        "RBC": r"(RBC)[^\d]*(\d{1,2}\.?\d*)",
        "WBC": r"(WBC)[^\d]*(\d{3,5}\.?\d*)",
    }

    extracted = {}
    for key, pattern in patterns.items():
        match = re.search(pattern, text, re.IGNORECASE)
        if match:
            extracted[key] = float(match.group(2))
    return extracted


def get_assistant() -> MedicalReportAssistant:
    """Instantiate and return the medical report assistant."""
    return MedicalReportAssistant()


def get_medicine_recommendations(summary_text: str) -> str:
    """Fetch AI-based medicine recommendations using Groq API."""
    api_key = os.getenv("GROQ_API_KEY")  # ensure this is set in api.env
    if not api_key:
        return "‚ö†Ô∏è Groq API key missing. Please check your api.env file."

    endpoint = "https://api.groq.com/openai/v1/chat/completions"
    prompt = f"""
    Based on this summary:
    {summary_text}

    Suggest safe, over-the-counter or commonly prescribed medicines (for informational purposes only).
    Format response as:
    - Medicine Name ‚Äî Purpose
    """

    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {api_key}"
    }

    data = {
        "model": "llama-3.1-8b-instant",
        "messages": [{"role": "user", "content": prompt}],
        "max_tokens": 250,
        "temperature": 0.5
    }

    try:
        response = requests.post(endpoint, headers=headers, json=data)
        if response.status_code == 200:
            return response.json()['choices'][0]['message']['content'].strip()
        else:
            return f"‚ö†Ô∏è Error fetching medicines: {response.text}"
    except Exception as e:
        return f"‚ö†Ô∏è API request failed: {e}"


# ---------------------------
# 8. Main interface: Tabs
# ---------------------------
tab1, tab2, tab3, tab4, tab5 = st.tabs([
    "Analyze Report",
    "‚ÑπÔ∏è About",
    "üß† Disease Prediction",
    "üíä Medication Reminder",
    "ü©ª Chest X-ray Analysis"
])

with tab1:
    # User query input
    query = st.text_area(
        "Enter your query (or leave blank to auto-analyze):",
        height=120,
        placeholder="e.g. Explain my blood test results"
    )

    if st.button("üöÄ Start Analysis", type="primary", use_container_width=True):
        if not st.session_state.uploaded_file:
            st.error("‚ùå Please upload a PDF medical report first.")
        else:
            with st.spinner("üß† Analyzing report with AI..."):
                try:
                    # Write temp PDF file
                    temp_pdf = f"temp_{uuid.uuid4().hex}.pdf"
                    with open(temp_pdf, "wb") as f:
                        f.write(st.session_state.file_bytes)

                    # Analyze via assistant
                    assistant = get_assistant()
                    prompt = query.strip() or (
                        "Please analyze this medical report and explain "
                        "the findings in simple terms."
                    )
                    result = assistant.analyze_query(prompt, temp_pdf)

                    # --- üéß Audio Output ---
                    audio_path = generate_audio(result)
                    st.markdown('<div class="audio-container">', unsafe_allow_html=True)
                    st.markdown('<h4>üîä Listen to Doctor\'s AI Opinion:</h4>', unsafe_allow_html=True)
                    st.audio(audio_path)
                    st.markdown('</div>', unsafe_allow_html=True)

                    # --- ü©∫ Doctor's AI Opinion ---
                    st.markdown("### ü©∫ Doctor‚Äôs AI Opinion")
                    st.markdown(
                        f'<div class="result-box">{result}</div>',
                        unsafe_allow_html=True
                    )

                    # --- üíä Medicine Recommendation Section ---
                    with st.spinner("üíä Fetching recommended medicines..."):
                        medicine_suggestions = get_medicine_recommendations(result)

                    st.markdown("### üíä Recommended Medicines")
                    st.markdown(
                        f'<div class="result-box">{medicine_suggestions}</div>',
                        unsafe_allow_html=True
                    )
                    st.markdown("""
                    **üìù Note:**  
                    These medicine suggestions are generated by AI for **educational purposes only**.  
                    Do **not** start, stop, or change any medication without consulting a qualified healthcare professional.
                    """)

                    # --- üßæ PDF Download Section (AFTER medicines are ready) ---
                    with st.spinner("üßæ Preparing downloadable report..."):
                        pdf_path = generate_pdf(result, medicine_suggestions)

                    with open(pdf_path, "rb") as pdf_file:
                        st.download_button(
                            label="üì• Download Full Report (PDF)",
                            data=pdf_file,
                            file_name="MedScope_AI_Report.pdf",
                            mime="application/pdf",
                        )

                    st.success("‚úÖ Analysis and medicine suggestions completed successfully!")

                except Exception as e:
                    st.error(f"‚ö†Ô∏è Error: {e}")
                    st.error("Please try again with a different PDF file")
                finally:
                    if os.path.exists(temp_pdf):
                        os.remove(temp_pdf)

with tab2:
    # About section
    st.markdown("""
    ## About MedSMedScope AI

    MedSMedScope AI
    leverages advanced AI to transform complex medical reports 
    into clear, actionable insights in seconds.

    **Key Capabilities**
    - Comprehensive PDF report interpretation
    - Natural language explanations
    - Integrated audio playback for auditory learners
    - Privacy-first design‚Äîno data is stored

    **How It Works**
    1. **Upload** your medical report (PDF)
    2. **Query** specific points or run a full analysis
    3. **Review** both text and audio summaries

    Built on the [CAMEL-AI](https://www.camel-ai.org/) framework & 
    [Groq Inference](https://groq.com/) and powered by secure, on-device 
    processing to ensure patient confidentiality.
    """)


# ---------------------------
# 9. Footer
# ---------------------------
st.markdown("---")
st.caption("MedSMedScope AI")
with tab3:
    st.subheader("üß† AI Disease Prediction from Report")
    st.markdown("""
    This feature automatically extracts your lab values (like **Glucose, TSH, Hemoglobin, etc.**) 
    from the uploaded report and predicts the most likely disease using our trained Neural Network model.
    """)

    if not st.session_state.uploaded_file:
        st.warning("‚ö†Ô∏è Please upload a medical report in the sidebar first.")
    else:
        with st.spinner("üîç Extracting medical values and predicting disease..."):
            try:
                # Load PDF text from uploaded file
                temp_pdf = f"temp_{uuid.uuid4().hex}.pdf"
                with open(temp_pdf, "wb") as f:
                    f.write(st.session_state.file_bytes)

                assistant = get_assistant()
                result_text = assistant.analyze_query("Extract all medical values from this report.", temp_pdf)

                # Extract lab values
                extracted_values = extract_lab_values(result_text)
                st.markdown("### üß¨ Extracted Lab Values:")
                st.json(extracted_values)

                if len(extracted_values) == 0:
                    st.error("‚ùå No valid lab values detected. Please try a detailed report.")
                else:
                    # Prepare user data for prediction
                    user_data = pd.DataFrame([extracted_values])
                    for col in feature_names:
                        if col not in user_data.columns:
                            user_data[col] = 0

                    X_user_scaled = scaler.transform(user_data[feature_names])

                    preds = model.predict(X_user_scaled)
                    predicted_class = np.argmax(preds)
                    predicted_disease = label_encoder.inverse_transform([predicted_class])[0]
                    confidence = np.max(preds) * 100

                    st.success(f"‚úÖ Predicted Disease: **{predicted_disease}**")
                    st.info(f"üìä Confidence Level: **{confidence:.2f}%**")

            except Exception as e:
                st.error(f"‚ö†Ô∏è Error during disease prediction: {e}")
            finally:
                if os.path.exists(temp_pdf):
                    os.remove(temp_pdf)

# ---------------- TELEGRAM MESSAGE FUNCTION ----------------
# ---------------- TAB 4: REMINDER ----------------
reminder_file = "reminders.csv"

with tab4:
    st.header("üíä Weekly Medication Scheduler")
    st.markdown("Plan your medicines for the week and get Telegram reminders automatically!")

    with st.form("reminder_form"):
        col1, col2 = st.columns(2)
        with col1:
            medicine = st.text_input("Medicine Name", placeholder="e.g. Metformin")
        with col2:
            dosage = st.text_input("Dosage", placeholder="e.g. 500mg")

        st.markdown("### üóìÔ∏è Select Days")
        days = {d: st.checkbox(d) for d in
                ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]}

        st.markdown("### üïê Select Time")
        time_options = {
            "Morning (8:00 AM)": st.checkbox("Morning (8:00 AM)"),
            "Afternoon (1:00 PM)": st.checkbox("Afternoon (1:00 PM)"),
            "Night (8:00 PM)": st.checkbox("Night (8:00 PM)"),
        }

        include_custom = st.checkbox("‚è∞ Include Custom Time")
        custom_time_value = st.time_input("Select Custom Time", value=datetime.time(9, 30), step=60)

        phone = st.text_input("WhatsApp Number (with country code)", placeholder="+91XXXXXXXXXX")

        submit = st.form_submit_button("üíæ Save Reminder")

        if submit:
            selected_days = [d for d, v in days.items() if v]
            selected_times = []
            for label, sel in time_options.items():
                if sel:
                    if "Morning" in label: selected_times.append("08:00")
                    elif "Afternoon" in label: selected_times.append("13:00")
                    elif "Night" in label: selected_times.append("20:00")
            if include_custom:
                selected_times.append(custom_time_value.strftime("%H:%M"))

            if not medicine or not dosage or not selected_days or not selected_times:
                st.warning("‚ö†Ô∏è Please fill all fields correctly.")
            else:
                entries = []
                for day in selected_days:
                    for time_val in selected_times:
                        entries.append({
                            "Medicine": medicine,
                            "Dosage": dosage,
                            "Day": day,
                            "Time": time_val,
                            "Phone": phone,
                            "Added_On": datetime.date.today()
                        })
                df_entry = pd.DataFrame(entries)
                if os.path.exists(reminder_file):
                    df_old = pd.read_csv(reminder_file)
                    df_combined = pd.concat([df_old, df_entry], ignore_index=True)
                    df_combined.to_csv(reminder_file, index=False)
                else:
                    df_entry.to_csv(reminder_file, index=False)

                st.success(f"‚úÖ Reminder added for {medicine} ({dosage}) at {', '.join(selected_times)}")

                BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
                CHAT_ID = os.getenv("TELEGRAM_CHAT_ID")
                if BOT_TOKEN and CHAT_ID:
                    msg = f"üíä New Reminder Added!\n{medicine} ({dosage}) on {', '.join(selected_days)} at {', '.join(selected_times)}"
                    send_telegram_message(msg, CHAT_ID, BOT_TOKEN)
                else:
                    st.warning("‚ö†Ô∏è Telegram bot not configured. Please check api.env.")

    st.markdown("---")
    st.subheader("üìã Active Reminders")
    if os.path.exists(reminder_file):
        df = pd.read_csv(reminder_file)
        st.dataframe(df, use_container_width=True)
        if st.button("üóëÔ∏è Clear All Reminders"):
            os.remove(reminder_file)
            st.success("‚úÖ All reminders cleared.")
    else:
        st.info("No reminders yet.")


# ---------------- REMINDER SCHEDULER ----------------
def start_reminder_scheduler():
    """Run a background thread to check reminders every 60 seconds and send Telegram alerts."""
    if "scheduler_running" in st.session_state and st.session_state.scheduler_running:
        return

    def check_loop():
        load_dotenv("api.env")
        BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
        CHAT_ID = os.getenv("TELEGRAM_CHAT_ID")
        print("‚úÖ Reminder Scheduler Started")
        while True:
            now = datetime.datetime.now()
            current_day = now.strftime("%A")
            current_time = now.strftime("%H:%M")
            if os.path.exists(reminder_file):
                try:
                    df = pd.read_csv(reminder_file)
                    for _, row in df.iterrows():
                        day = str(row["Day"]).strip()
                        time_val = str(row["Time"]).strip().zfill(5)
                        med = str(row["Medicine"]).strip()
                        dose = str(row["Dosage"]).strip()
                        if day == current_day and time_val == current_time:
                            msg = f"üíä Reminder: Take {med} ({dose}) now!"
                            send_telegram_message(msg, CHAT_ID, BOT_TOKEN)
                            print(f"üîî Reminder triggered for {med} at {current_time}")
                except Exception as e:
                    print("‚ö†Ô∏è Error checking reminders:", e)
            time.sleep(60)

    thread = threading.Thread(target=check_loop, daemon=True)
    thread.start()
    st.session_state.scheduler_running = True


# ‚úÖ Start scheduler automatically when app loads
start_reminder_scheduler()


# ---------------- TAB 5: CHEST X-RAY ANALYSIS ----------------
# ---------------- GROQ EXPLAIN CHEST FUNCTION ----------------
def groq_explain_chest(label: str, confidence: float) -> str:
    """Use Groq LLM to explain the CNN result with causes, actions, and precautions."""
    api_key = os.getenv("GROQ_API_KEY")
    if not api_key:
        return "‚ö†Ô∏è GROQ_API_KEY missing in api.env. Add GROQ_API_KEY=your_key and restart the app."

    prompt = f"""
    You are a medical AI assistant. A chest X-ray model predicted: **{label}** with confidence {confidence:.2f}%.
    Please explain in simple, patient-friendly language:
    1) What this finding means.
    2) Common causes and when to worry.
    3) Immediate steps/lifestyle tips.
    4) What to avoid and key precautions.
    Keep it under 220 words; use short bullet points where helpful.
    End with: 'Consult a clinician for confirmation.'
    """

    try:
        response = requests.post(
            "https://api.groq.com/openai/v1/chat/completions",
            headers={"Authorization": f"Bearer {api_key}", "Content-Type": "application/json"},
            json={
                "model": "llama-3.1-8b-instant",
                "messages": [{"role": "user", "content": prompt}],
                "max_tokens": 320,
                "temperature": 0.5
            },
            timeout=30
        )
        if response.status_code == 200:
            return response.json()["choices"][0]["message"]["content"].strip()
        else:
            return f"‚ö†Ô∏è Groq API error: {response.text}"
    except Exception as e:
        return f"‚ö†Ô∏è Groq request failed: {e}"

# ---------------- TAB 5: CHEST X-RAY ANALYSIS ----------------
with tab5:
    st.header("ü©ª Chest X-ray AI Diagnosis")
    st.markdown("""
    Upload a **Chest X-ray image** (JPG/PNG).  
    The AI model predicts whether it‚Äôs **Normal** or **Pneumonia**,  
    and then Groq AI explains the condition in simple, patient-friendly terms.
    """)

    upload_xray = st.file_uploader("üì§ Upload Chest X-ray", type=["jpg", "jpeg", "png"])

    if upload_xray is not None:
        # Step 1: Show uploaded image
        st.image(upload_xray, caption="üì∏ Uploaded X-ray", use_container_width=True)

        try:
            # Step 2: CNN Preprocessing
            img = Image.open(upload_xray).convert("RGB")     # 3-channel color
            img_resized = img.resize((150, 150))             # match model training size
            x = np.array(img_resized, dtype=np.float32) / 255.0
            x = np.expand_dims(x, axis=0)                    # shape (1,150,150,3)

            # Debug info (for logs)
            print("üìè Input shape for model:", x.shape)
            print("üìê Model expects:", chest_model.input_shape)

            # Step 3: Model Prediction
            with st.spinner("üîé Analyzing X-ray using CNN model..."):
                probs = chest_model.predict(x)

            pred_idx = int(np.argmax(probs[0]))
            confidence = float(np.max(probs[0])) * 100.0
            label = CHEST_CLASS_LABELS[pred_idx] if pred_idx < len(CHEST_CLASS_LABELS) else f"Class {pred_idx}"

            # Step 4: Display Prediction
            st.success(f"‚úÖ Detected Condition: **{label}**")
            st.info(f"üìä Model Confidence: **{confidence:.2f}%**")

            # Step 5: Generate AI Explanation using Groq
            with st.spinner("üß† Generating AI explanation & medical guidance..."):
                explain = groq_explain_chest(label, confidence)
            st.markdown("### ü©∫ AI Doctor‚Äôs Explanation")
            st.markdown(explain)

            # Step 6 (Optional): Grad-CAM visualization placeholder
            with st.expander("üß¨ View AI Attention Map (Grad-CAM)"):
                st.markdown("This feature highlights where the CNN focused while making its decision.")
                st.markdown("_Coming soon ‚Äî will visualize heatmap regions on the X-ray._")

        except Exception as e:
            st.error(f"‚ö†Ô∏è Error processing image: {e}")
